# MySQL高级

---

## 存储引擎

### 一、MySQL体系结构

#### (一) 体系结构图

<img src="pics/image-20220314220459142.png" alt="image-20220314220459142" style="zoom:70%;" />

#### (二) MySQL Server 分层结构

- *连接层*

  > 客户端的连接处理、**认证授权**相关操作、安全方案、最大连接数

- *服务层*

  > 核心，有SQL相关接口，负责SQL解析和优化

- *存储引擎层*

  > 可插拔的存储引擎；
  >
  > 服务器会通过*API*与存储引擎进行交互

  > 注意，==**索引**是在存储引擎层实现的==

- *存储层*

  > 就是真正存储数据的

#### (三) 各层工作概述

- 连接层
  - 最上层是一些客户端和<u>链接服务</u>
  - 主要完成一些类似于**连接处理**、**授权认证**、及相关的**安全方案**
  - 服务器也会为安全接入的每个客户端验证它所具有的**操作权限**
- 服务层
  - 第二层架构主要完成大多数的<u>核心服务功能</u>
  - 如*SQL*接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行
  - 所有跨**存储引擎的功能**也在这一层实现，如过程、函数等
- 引擎层
  - 存储引擎真正的负责了<u>*MySQL*中数据的存储和提取</u>，
    服务器通过*API*和存储引擎进行通信。
  - 不同的存储引擎具有不同的功能，
    这样我们可以根据自己的需要，来选取合适的存储引擎
- 存储层
  - 主要是<u>将数据存储在文件系统</u>之上，并完成**与存储引擎的交互**

---

### 二、存储引擎简介

#### (一) 概念

- 存储引擎就是**存储数据**、**建立索引**、**操作数据**等技术的实现方式

- ==存储引擎是基于**数据表**的==，而不是基于库的，所以存储引擎也可被称为**表类型**

  > 表的默认存储引擎是*InnoDB*

#### (二) 相关语法

- 在**创建表**时指定**存储引擎**

  ```sql
  create table 表名(
      字段1 字段1类型 [comment 字段1注释]
      ...
      字段n 字段n类型 [comment 字段n注释]
  ) engine = innodb [comment 表注释];
  ```

- 查看当前数据库支持的存储引擎

  ```sql
  show engines
  ```


---

### 三、存储引擎特点

#### (一) InnoDB

- *简介*

  InnoDB是一种兼顾**高可靠性**和**高性能**的通用存储引擎

  > 在MySQL 5.5之后，InnoDB是 默认的MySQL存储引擎。

- *特点*

  - DML操作遵循ACID模型，支持**事务**
  - **行级锁**，提高并发访问性能
  - 支持**外键**FOREIGN KEY约束，保证数据的完整性和正确性

  > 总结：事务、行级锁、外键（这也是官方对InnoDB的Comment）

- *磁盘文件*

  ==***idb* 表空间文件**==

  innoDB引擎的每张表都会对应这样一个表空间文件【***xxx.idb***，xxx代表<u>表名</u>】，
  存储该表的**表结构**(sdi)、**数据**和**索引**。

  > .frm原本是**表结构**文件，
  > 但MySQL8.0后，frm被融入到新出的sdi数据字典中，
  > 而在InnoDB存储引擎中，sdi又融入到ibd中

  > 一个重要参数：`innodb_file_per_table`
  >
  > 决定到底是多张表<u>共享**表空间文件**</u>，还是每张表对应一个（默认）

  > 命令：`idb2sdi xxx.ibd`，查看**表结构**

- *逻辑存储结构*

  <img src="pics/image-20220316140703380.png" alt="image-20220316140703380" style="zoom:67%;" />

  > ==页==包含**索引页**和**数据页**，是<u>磁盘操作的最小单元</u>；
  >
  > 页的大小是固定的16K，区的大小是固定的1M；
  >
  > > 一个区可以包含64页

#### (二) MyISAM

- *简介*

  MyISAM是MySQL早期的默认存储引擎

- *特点*

  - 不支持<u>事务</u>，不支持<u>外键</u>
  - 支持**表锁**，不支持<u>行锁</u>
  - 访问速度快

- *磁盘文件*

  - xxx.sdi：存储**表结构**信息

    > Serialized Dictionary Information；文本文件，存放JSON格式数据

  - xxx.MYD：存储**数据**

  - xxx.MYI：存储**索引**

#### (三) Memory

- 简介

  Memory引擎的表数据是存储在**内存**中的，由于受到硬件问题或断电问题的影响，只能将这些表作为<u>临时表</u>或<u>缓存</u>使用。

- 特点

  - 内存存放，访问速度快
  - 支持hash索引（默认）

- 磁盘文件

  - xxx.sdi：存储**表结构**信息

  > **数据**是存放在**内存**中的，与磁盘文件无关

> 三种存储引擎对比：
>
> <img src="pics/image-20220316142513667.png" alt="image-20220316142513667" style="zoom:67%;" />

---

### 四、存储引擎选择

#### (一) 选择原则

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

#### (二) 应用场景

- ***InnoDB*** 

  > Mysql的默认存储引擎，支持事务 、外键。

  如果应用对**事务的完整性**有比较高的要求，在并发条件下要求**数据的一致性**，
  数据操作除了<u>插入和查询</u>之外，还包含很多的**更新、删除**操作，
  那么InnoDB存储引擎是比较合适的选择。

- ***MyISAM***

  如果应用是以读**操作**和**插入**操作为主，只有很少的<u>更新和删除</u>操作，
  并且对**事务的完整性、并发性**要求不是很高，
  那么选择这个存储引擎是非常合适的。

- ***MEMORY***

  > 将所有数据保存在内存中，访问速度快

  通常用于**临时表**及**缓存**；

  MEMORY的缺陷就是**对表的大小有限制**，太大的表无法缓存在内存中，
  而且无法保障**数据的安全性**。

> 在实际应用中，MyISAM常被**MongoDB**替代，MEMORY常被**Redis**替代

---

---

## 索引

### 一、索引概述

#### (一) 概念

- 索引是帮助MySQL**高效获取数据**的**<u>数据结构</u>**（有序）

  > 在数据之外，数据库还维护着**满足特定查找算法**的数据结构；
  >
  > 这些数据结构以**引用**的方式指向数据，这样就可以在其上使用**高效的查询算法** 

> 举例理解索引的作用：
>
> <img src="pics/理解索引作用.png" style="zoom:67%;" />

#### (三) 索引的特点

- *优点*

  - 提高**查询效率**，降低**<u>I/O成本</u>**

  - 通过索引排序可以降低**<u>分组和排序成本</u>**，降低CPU的消耗

    >比如order by、group by

- *缺点*

  - 索引列也需要**占用磁盘空间**

    > 但磁盘便宜

  - <u>更新表</u>时**维护索引**，降低效率

    > 但正常的业务不会有太多的更新表

---

### 二、索引结构

> MySQL的索引是在**<u>存储引擎</u>**层实现的，不同的存储引擎有不同的结构

#### (一) 索引结构分类

<img src="pics/索引结构分类.png" style="zoom:80%;" />

#### (二) 索引结构支持情况

<img src="pics/索引支持情况.png" style="zoom:67%;" />

#### (三) B树

- B-Tree：多路平衡查找树

  > 解决<u>二叉树形成链表</u>的问题，解决红黑树<u>大数据量层级较深</u>的问题
  >
  > ![](pics/B树定义.png)
  >
  > ![](pics/B树定义2.png)
  >
  > ![](pics/B树核心特性.png)

- B树高度问题

  > ![](pics/B树最小高度.png)
  >
  > ![](pics/B树最大高度.png)
  >
  > ![](pics/B树最大高度2.png)
  >
  > > 关键：**<u>分叉数</u>**和**关键字数**

- B树的插入和删除

  - 在插入key后，若导致原结点关键字数超过上限，则从**<u>中间位置</u>**将其中的关键字分为两部分,左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置的结点插入原结点的**<u>父结点</u>**

    > 中间位置指的是$\lfloor\frac m2\rfloor$

  - 删除

    - 若被删除关键字在**<u>终端节点</u>**，则直接删除该关键字

      > 要注意节点关键字个数是否低于下限

    - 若被删除关键字在**<u>非终端节点</u>**，则用**<u>直接前驱</u>**或**<u>直接后继</u>**来替代被删除的关键字

      >直接前驱:当前关键字左侧指针所指子树中“最右下”的元素
      >
      >直接后继:当前关键字右侧指针所指子树中“最左下”的元素

      >对**<u>非终端</u>**结点关键字的删除，必然可以转化为对**<u>终端</u>**结点的删除操作

    - 若删除后关键字个数低于下限，

      - 兄弟够借，且与此结点右(或左)兄弟结点的关键字个数还很宽裕，则需要调整该结点、右(或左)兄弟结点及其双亲结点(**<u>父子换位法</u>**) 

        > 找**<u>后继</u>**，找**<u>前驱</u>**

      - 兄弟不够借，且此时与该结点相邻的左、右兄弟结点的关键字个数均达到下限则将关键字删除后与左(或右) 兄弟结点及**<u>双亲结点</u>**中的关键字进行合并

        > **<u>合并兄弟和双亲</u>**

#### (四) MySQL中的B+树索引

- MySQL索引数据结构对经典的B+Tree进行了优化，在原B+Tree的基础上,增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree,提高<u>**区间访问的性能**</u>。

  > 叶子节点之间形成了**<u>双向链表</u>**

#### (五) Hash索引结构

- 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中

  > 同时会用**<u>拉链法</u>**解决冲突问题

> Hash索引特点：
>
> - Hash索引只能用于**<u>对等比较</u>**(<u>=，in</u>)， 不支持范围查询(between, >，<, ...)
>
> - 无法利用索引完成**<u>排序</u>**操作
>
>   > hash值可能是无序的
>
> - 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引

> 存储引擎支持情况：
>
> 在MySQL中，支持hash索引的是**<u>Memory引擎</u>**
>
> InnoDB中 具有**<u>自适应hash功能</u>**，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。

<img src="pics/B树高度问题.png" style="zoom:67%;" />

---

### 三、索引分类

#### (一) 按字段分类

![](pics/索引按字段分类.png)

> - 有主键约束的自动会**自动创建主键索引**	
> - <u>添加了`unique`约束的字段</u>也会**自动创建索引**

#### (二) 按InnoDB中索引存储形式分类

![](pics/InnoDB索引分类.png)

>- 聚集索引必须有，不然数据（记录）都没地方存放（而且只能有一个）
>- **聚集索引的选取规则**
>  1. **<u>主键</u>**索引
>  2. 第一个**<u>唯一</u>**索引
>  3. InnoDB自动生成一个rowid作为**隐藏的聚集索引**

> 聚集索引和二级索引的结构举例：
>
> <img src="pics/Ino索引结构举例.png" style="zoom:67%;" />
>
> - 聚集索引的叶子节点会直接存储数据记录
> - 二级索引的叶子节点不会再存储数据记录了

> 二级索引的查询举例：
>
> <img src="pics/二级索引查询举例.png" style="zoom:67%;" />
>
> - 以这种方式查询**整条记录**，还需要**回表**
> - 如果是非唯一性索引，扫描到相同值之后还会继续扫描，**直到不相等**

---

### 四、索引语法

#### (一) 创建索引

```sql
create index idx_name on table_name(index_col_name, ...);
```

> - :star:`index`之前可以有`unique`或`fulltext`修饰，如果不修饰就是**常规索引**
>
>   > 如果要创建**<u>唯一索引</u>**，这个字段就**<u>不能有重复数据</u>**，否则创建失败
>
> - 一个索引可以只关联一个字段，称为**单列索引**；也可以关联多个字段，称为**组合索引**
>
>   > 组合索引的**顺序**是会产生影响的

#### (二) 查看索引

```sql
show index from table_name;
```

#### (三) 删除索引

```sql
drop index index_name on table_name;
```

---

### 五、SQL性能分析

> SQL优化主要优化的是**查询语句**

#### (一) SQL执行频率

```sql
show session|global status like 'Com_______'
```

> - global代表全局，session代表当前会话
>
> - 执行结果举例
>
>   ![](pics/SQL执行.png)
>
>   > 主要看insert、delete、update、select

#### (二) 慢查询日志

- 慢查询日志记录了所有执行时间超过指定参数的所有SQL语句的日志

  > 指定参数：long_ query _time,单位:秒，默认10秒

- MySQL的慢查询日志**默认没有开启**，需要在MySQL的配置文件(/etc/my.cnf)中配置信息

  >- 查看是否开启：
  >
  >  ```sql
  >  show variables like 'slow_query_log';
  >  ```
  >
  >- 开启方法
  >
  >  ```properties
  >  #开启MySQl慢日志查询开关
  >  slow_query_log=1
  >  #设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
  >  long_query_time=2
  >  ```
  >
  >  > 配置完毕之后,通过以下指令**重新启动MySQL服务器**进行测试,查看慢日志文件中记录的信息**/var/lib/mysql/localhost-slow.log**
  >  >
  >  > ```sql
  >  > systemctl restart mysqld
  >  > ```

#### (三) profile详情

> show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了

- 查看当前数据库是否支持profile操作

  ```sql
  SELECT @@have_ profiling;
  ```

- 默认profiling是关闭的，可以通过set语句在session/global级别开启profiling

  ```sql
  set session|global profiling=1;
  ```

- 执行一系列的业务SQL的操作， 然后通过如下指令查看指令的执行耗时

  ```sql
  #查看每一条SQL 的耗时基本情况
  show profiles;
  #查看指定query_id的SQL语句各个阶段的耗时情况
  show profile for query query_id;
  #查看指定query_id的SQL语句CPU的使用情况
  show profile cpu for query query_id; 
  ```

  > query_id可以通过show profiles命令查看

#### (四) explain执行计划

- EXPLAIN或者DESC命令获取MySQL**<u>如何执行SELECT语句</u>**的信息，包括在SELECT语句执行过程中表**<u>如何连接</u>**和**<u>连接的顺序</u>**

- 语法

  ```sql
  #直接在select语句之前加.上关键字explain/desc
  EXPLAIN SELECT语句;
  ```

- 各字段含义

  - *id*：select查询的**序列号**,表示查询中执行select子句或者是操作表的**<u>顺序</u>**

    > id相同，执行顺序从**上到下**; id不同，值**越大**，越先执行

    > 注：一条DQL的explain可能出现多条执行计划，比如表连接的时候

  - *select_type*：代表**查询类型**

    > SIMPLE：简单表，即不使用**表连接**或者**子查询**
    >
    > PRIMARY：**主**查询,即**外层的查询**
    >
    > UNION：UNION中的**第二个或者后面的**查询语句
    >
    > SUBQUERY：SELECT/WHERE之后**包含的子查询**

  - :star:***type***：表示**连接/访问类型**

    > 性能由好到差的连接类型为
    >
    > *NULL*、*system*、 *const*、 *eq_ref*、*ref*、*range*、*index*、 *all*
    >
    > > *NULL*：不访问任何表的时候才是
    > >
    > > *system*：访问一张系统表才有可能
    > >
    > > *const*：根据**主键**和**唯一索引**查询
    > >
    > > *ref_eq*：用于**联表**查询，按联表的主键或唯一键查询
    > >
    > > *ref*：使用**非唯一性索引**查询
    > >
    > > *range*：有范围的索引扫描（出现了`between`、`in`、`or`、`and < >`等）
    > >
    > > *index*：遍历了**整个索引树**（也是一种全表扫描，甚至还可能回表）
    > >
    > > *all*：代表**全表扫描**

  - ***possible_key***：可能应用在这张表上的索引，一个或多个

  - ***key***：实际用到的索引，如果没有用到就是NULL

  - ***key_len***：表示索引中使用的字节数

    > 该值为索引字段最大可能长度,并非实际使用长度,在不损失精确性的前提下，长度**越短越好**

  - *rows*：MySQL认为必须要执行**查询的行数**

    > 在innodb引擎的表中，是一个**估计值**，可能并不总是准确的。

  - *filtered*：表示返回结果的行数占需**读取行数**的百分比
  
    > 注意是读取整条行记录数，而不是读取某一个索引的次数
  
    > filtered 的值越大越好，根据主键查询时是100.00
  
  - ***extra***：额外信息
  
    > 在SQL优化中会讲解部分extra的内容

> 举例：
>
> ![](pics/explain举例1.png)
>
> <img src="pics/explian举例2.png" style="zoom:150%;" />

---

### 六、索引使用

#### (一) 最左前缀法则

- 如果索引了多列(**联合索引**)，要遵守最左前缀法则。

- 最左前缀法则指的是：查条件询从**<u>索引的最左列</u>**开始,并且**<u>不跳过索引中的列</u>**

  > 如果**最左侧的列不存在**，则索引**全部失效**，**全表**扫描
  >
  > 如果**跳跃某一列,** 索引将**部分失效**
  >
  > > 跳跃**后面的字段索引**失效，索引长度也会跟着变化

  > 注意，这与where中的字段**顺序无关**，只与在筛选条件中**是否出现**有关

  > 因为联合索引在创建的时候是**从最左侧的列开始排序**的，
  >
  > 相等时再依次按照后面的列排序（相当于多位数比大小）

#### (二) 范围查询

- **联合索引**中出现**范围查询**，范围查询右侧的列索引失效

  > 因为在B+树的查找中，一个**数据页**中会使用**二分查找**，在联合索引中一个字段出现范围取值时，另一个字段就是**无序**的，无法再使用二分查找

#### (三) 索引失效

##### 1、单字段运算导致的

- 在索引列上进行**运算**操作，索引失效

  > 包括函数运算；
  >
  > 但如果只是参与比较、判断是否为NULL，可能不会失效

- 隐式类型转换（比如**字符串不加单引号**）会导致索引失效

  > 会出现可能用到的索引，但实际上没有使用

- **头部模糊匹配**，索引失效

  > 尾部不会失效

##### 2、多字段导致的

- *or*连接时，**有一侧没有索引**，索引一定失效

  > 可以通过给另一列加上索引来解决这个问题

- **数据分布影响**：*MySQL*评估使用索引比全表扫描慢时，索引失效

  > 一般是**要查出来的数据接近全表**的情况

#### (五) SQL提示

- 在SQL语句中加入一些**人为的提示**来达到优化操作的目的

  > 优化数据库的重要手段

- 语法

  ```sql
  select ... use|ignore|force index(idx_name)
  ```

  > *use*和*ignore*只是建议MySQL，而*force*是强制MySQL

#### (六) 覆盖索引

- 如果要查询出来的列包含于**索引相关列**，则不需要**<u>回表</u>**查询，这就是覆盖索引

  > 对于二级索引，**索引本身**和**主键**都是索引相关列

  > 如果没有回表，即索引覆盖，*Extra*中会显示 *Using where*；*Using index*；
  >
  > > *Using index*就代表覆盖索引，
  > >
  > > 如果出现*Using where*，代表索引不仅用来读取数据，还用来当作过滤条件，没出现就说明索引只是用来本身当作数据来读了
  >
  > 如果回表了，*Extra*中会显示 *Using index condition*

- *单列索引与联合索引*

  - 在业务场景中，如果存在多个查询条件,考虑针对于查询字段建立索引时，
    建议建立**<u>联合索引</u>**，而非单列索引
  
    > 建立联合索引就相当于把这两个数据**存放在一棵索引树上**了，减少回表
  
    >MySQL自动评估时可能会受单列索引的影响，所以最好用`use index()`关键字
  
  - 当然，创建联合索引时要注意**<u>顺序</u>**，尽量**把<u>唯一性</u>的放在左侧**

> 举例：需要建立联合索引的情况
>
> <img src="pics/联合索引举例.png" style="zoom:60%;" />

> 联合索引查询举例：
>
> <img src="pics/联合字段查询举例.png" style="zoom:67%;" />
>
> 创建联合索引的时候就没必要加上**主键**了

#### (七) 前缀索引

- *背景*

  - 当字段类型为字符串(***varchar***, ***text***等 )时,有时候需要**索引很长的字符串**,这会让索引变得很大,查询时，浪费大量的磁盘*IO*，影响查询效率。
  - 此时可以只将字符串的一部分前缀,建立索引,这样可以大大节约索引空间，从而提高索引效率。

- *语法*

  ```sql
  create index idx_xxx on table_name(column(n));
  ```

  > n代表使用前n个字符

- *前缀长度*

  - 可以根据索引的选择性来决定

  - <u>**选择性**</u>是指**不重复的索引值**(基数)和数据表的**记录总数**的比值

    > 索引选择性越高则查询效率越高,

    > 唯一索引的选择性是1, 这是最好的索引选择性,性能也是最好的。

  - 求法：借助**聚合函数**和**查询结果去重**

    ```sql
    #用email举例
    select count(distinct email) / count(*) from tb_user;
    select count(distinct substring(email, 1, 5)) / count(*) from tb_user;
    ```

  - 查看：`show index`命令的`Sub_part`字段

> 查询过程举例：
>
> ![](pics/前缀索引查询举例.png)
>
> 依然需要**回表**，对比**是否完全相等**；
>
> 如果不是**唯一性**索引，**回表之后**还会回到原来的索引树上，继续向下比对，直到不相等

---

### 七、索引设计原则

#### (一) 表

- 针对于数据量较大，且查询比较频繁的表建立索引。

#### (二) 单个字段

- 针对于常作为**<u>查询条件</u>**(where) 、 **<u>排序</u>**(order by)、**<u>分组</u>**(group by)操作的字段建立索引

- 尽量选择**<u>区分度高的列</u>**作为索引，尽量建立唯一索引，区分度越高,使用索引的效率越高

  > 比如姓名、状态这种字段就不要设成索引

- 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立**<u>前缀索引</u>**

  > 同时需要考虑**<u>选择度</u>**

- 如果索引列不能存储NULL值，请在创建表时使用**<u>NOT NUL约束</u>**它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

#### (三) 多个字段

- 尽量使用**<u>联合索引</u>**，减少单列索引，查询时，联合索引很多时候可以**<u>覆盖索引</u>**，节省存储空间，避免**<u>回表</u>**,提高查询效率。
- 要控制索引的数量,索引并不是多多益善,索引越多，**<u>维护索引</u>**结构的代价也就越大，会影响增删改的效率

---

---

## SQL优化

---

---

### 一、插入数据

---

#### (一) insert优化

- 需要插入多条记录时，一次**批量插入**

  > 每次*insert*都要连接数据库，所以一次批量插入更好

  > 当然一次批量插入也建议不要多于*1000*条，实在太多了还是需要拆分一下的

  ```sql
  insert into tb_test(id, name) values(1, 'Tom'), (2, 'Tom'), (3, 'Jerry');
  ```

- 手动提交事务

  > *MySQL*默认自动提交，频繁的事务也会影响效率

  > 建议手动控制事务，多条*insert*语句写在一次事务中

- 主键顺序插入

  > 取决于*MySQL*的数据组织结构；
  >
  > 顺序比乱序效率高

#### (二) 大批量插入数据

> 如果一次性需要插入**大批量数据**，使用*insert*语句插入性能较低

- 此时可以使用*MySQL*数据库提供的<u>*load*指令</u>进行插入

  > *load*的是一个**本地文件**，这个本地文件中的数据组织遵循某种规则

  > 性能提升是很明显的

- 使用方法

  1. 客户端连接服务端时，加上参数`--local-infile`

     ```sql
     mysql --local-infile -uroot -p123456
     ```

  2. 设置全局参数`local_infile`为`1`，开启**从本地加载文件导入数据**的开关

     ```sql
     set global local_infile = 1;
     ```

  3. 执行`load`指令将准备好的数据加载到表中

     ```sql
     load data local infile '路径' into table '表名' 
     	fields terminated by '字段分隔符' 
     	lines terminated by '行记录分隔符'
     ```

> 示例：
>
> <img src="pics/image-20220314215432997.png" alt="image-20220314215432997" style="zoom:67%;" />

---

### 二、主键优化

---

#### (一) 数据组织方式

- 在*InnoDB*存储引擎中，表数据都是根据<u>主键</u>**顺序组织**存放的
- 这种存储方式的表称为**索引组织表**(*index organized table IOT*)

> B+ 树举例：（聚集索引）
>
> <img src="pics/image-20220314215944269.png" alt="image-20220314215944269" style="zoom:67%;" />
>
> 每一个橙色的块都是一个**数据页**
>
> 回顾 InnoDB 逻辑存储结构：
>
> <img src="pics/image-20220314220025273.png" alt="image-20220314220025273" style="zoom:60%;" />

#### (二) 深入理解插入数据的流程

- 有关数据页的介绍：

  页可以为空，也可以填充一半，也可以填充100%。

  每个页包含了 ***2-N*** 行数据（如果一行数据多大, 会行溢出），<u>根据主键排列</u>。

- 主键<u>顺序</u>插入：

  <img src="pics/image-20220319214341955.png" alt="image-20220319214341955" style="zoom:67%;" />

  > 不会发生**页分裂**

- 主键<u>乱序</u>插入：

  为了维护叶子节点的有序性，需要**==页分裂==**：

  <img src="pics/image-20220319214605709.png" alt="image-20220319214605709" style="zoom:67%;" />

  <img src="pics/image-20220319214622194.png" alt="image-20220319214622194" style="zoom:67%;" />

  <img src="pics/image-20220319214635883.png" alt="image-20220319214635883" style="zoom:67%;" />

  <img src="pics/image-20220319214700159.png" alt="image-20220319214700159" style="zoom:67%;" />

> 页合并：
>
> 当删除一行记录时，实际上记录并没有被<u>物理删除</u>，只是记录**被标记(flaged)**，为删除并且它的空间变得允许被其他记录声明使用。
>
> 当页中删除的记录达到`MERGE_THRESHOLD`( 默认为页的50%)，InnoDB会开始寻找最靠近的页(前或后)看看是否可以**将两个页合并**以优化空间使用。
>
> <img src="pics/image-20220319215029286.png" alt="image-20220319215029286" style="zoom:67%;" />
>
> <img src="pics/image-20220319215100489.png" alt="image-20220319215100489" style="zoom:67%;" />
>
> > 注：`MERGE_THRESHOLD`可以在<u>创建表</u>或者<u>创建索引</u>时自行指定

#### (三) 主键设计原则

- 尽量降低主键长度

  > **二级索引**可以有很多个，其<u>叶子节点</u>上存放的就是行记录的**主键**

- 插入数据时，尽量选择**顺序插入**

  > 建议使用`AUTO_INCREMENT`自增主键

> 尽量不要使用UUID或自然主键（如身份证号），因为很可能<u>无序且较长</u>

- 业务操作中避免修改主键

  > 不然还要大规模修改**索引结构**

---

### 三、order by 优化

#### (一) 排序的两种方式

- Using firesort

  通过表的**索引**或**全表扫描**，读取满足条件的数据行，然后在排序缓冲区*sort buffer*中完成排序操作

  > 所有不是<u>通过索引直接返回排序结果</u>的排序都叫*FileSort*排序。

- Using index

  通过**有序索引**顺序扫描直接返回有序数据，这种情况即为*using index*

  > 不需要额外排序，操作效率高。

> 这两个信息会出现在<u>执行计划的***Extra***部分</u>

> 举例：
>
> > 在加入name_phone联合索引、并且查询时**覆盖索引**的前提下
>
> 书写顺序（也就是**排序优先级**）<u>遵循索引顺序</u>，且同为升序或降序：
>
> <img src="pics/image-20220319220909595.png" alt="image-20220319220909595" style="zoom:67%;" />
>
> <img src="pics/image-20220319220929295.png" alt="image-20220319220929295" style="zoom:67%;" />
>
> <img src="pics/image-20220319221016255.png" alt="image-20220319221016255" style="zoom:67%;" />
>
> > 降序时需要<u>反向扫描索引</u>（*Backward index scan*）
>
> ----
>
> 书写顺序（也就是**排序优先级**）<u>不遵循索引顺序</u>：
>
> <img src="pics/image-20220319221251643.png" alt="image-20220319221251643" style="zoom:67%;" />
>
> ----
>
> 一升一降：
>
> <img src="pics/image-20220319221524667.png" alt="image-20220319221524667" style="zoom:67%;" />
>
> 查看索引树的排序方式：
>
> <img src="pics/image-20220319221644581.png" alt="image-20220319221644581" style="zoom:67%;" />
>
> > A代表Asc
>
> 创建索引时指定排序方式：
>
> <img src="pics/image-20220319221805460.png" alt="image-20220319221805460" style="zoom:67%;" />
>
> <img src="pics/image-20220319221829180.png" alt="image-20220319221829180" style="zoom:67%;" />
>
> <img src="pics/image-20220319221856298.png" alt="image-20220319221856298" style="zoom:67%;" />
>
> ---
>
> > 如果不覆盖索引：
> >
> > <img src="pics/image-20220319222749268.png" alt="image-20220319222749268" style="zoom:67%;" />
> >
> > 使用索引后**多次回表**导致效率严重下降，不如直接不要索引，在缓冲区中排序

#### (二) order by 优化原则

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。

- 尽量使用覆盖索引。

- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。

- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_ buffer_size

  > 默认256k，可以通过指令`show variables like 'sort_buffer_size'`查看

---

### 四、group by 优化

#### (一) 举例

不加索引，使用**临时表**分组，效率低（Using temporary）：

<img src="pics/image-20220319223641448.png" alt="image-20220319223641448" style="zoom:67%;" />

创建（联合）索引后，使用索引分组，效率高（Using index）：

<img src="pics/image-20220319223741495.png" alt="image-20220319223741495" style="zoom:67%;" />

使用索引分组但不满足<u>最左前缀法则</u>：

<img src="pics/image-20220319223918998.png" alt="image-20220319223918998" style="zoom:67%;" />

> 这里之所以还会用一下索引，是因为毕竟还可以**索引覆盖**，读取数据还是比不用索引方便的；
>
> 联合分组满足最左前缀法则：
>
> <img src="pics/image-20220319224135114.png" alt="image-20220319224135114" style="zoom:67%;" />

使用索引分组，不满足<u>最左前缀法则</u>，但先<u>使用左侧列进行筛选</u>了：

<img src="pics/image-20220319224324793.png" alt="image-20220319224324793" style="zoom:67%;" />

> `where`是在`group by`之前执行的

#### (二) 原则

在分组操作时，通过**索引**提高效率

> 索引的使用也要满足<u>最左前缀法则</u>

---

### 五、limit优化

#### (一) limit分页的问题

大数据量下，使用limit分页，当前页数越靠后，查询耗时越长，**性能越低**

> 一个常见又非常头疼的问题就是`limit 2000000, 10`，此时需要MySQL排序前2000010记录,仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。

#### (二) 优化方案

覆盖索引 + from子查询

> <img src="pics/image-20220321095314918.png" alt="image-20220321095314918" style="zoom:67%;" />
>
> > 如果使用`select *`，就要将`*`转化成所有字段，那么所有字段都要查一遍，其中有不带索引的字段，就需要全表扫描

---

### 六、count优化

#### (一) 问题

- MyISAM引擎把一个表的总行数存在了磁盘上，因此执行`count(*)`的时候会直接返回这个数，效率很高

  > 当然如果后面还添加了`where`筛选，那么效率还是低

- InnoDB引擎就麻烦了，它执行`count(*)`的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

> 优化思路：可以使用redis之类的缓存，自己计数

#### (二) count用法对比

- `count()`是一个**聚合函数**，对于返回的结果集，<u>一行行地判断</u>，
  如果count函数的参数不是NULL，累计值就加1，否则不加，最后返回**累计值**。

- 用法

  - `count(*)`：总记录数

    InnoDB引擎<u>并不会把全部字段取出来</u>，而是专门做了**优化**，==不取值==，服务层**直接按行进行累加**。

  - `count(主键)`：总记录数

    InnoDB引擎会遍历整张表，把每一行的主键id<u>值都取出来</u>，返回给服务层。服务层拿到主键后，直接按行进行**累加**

    >主键不可能为null；

    > 为什么还要取值？因为服务层都点明了字段，该取值还是要取的，只不过服务层没有直接用到这个值而已

  - `count(字段)`：该字段不为NULL的记录数

    - 没有not null约束

      InnoDB引擎会遍历整张表，把每一行的<u>字段值都取出来</u>，返回给服务层，<u>服务层判断是否为null</u>，不为null则计数**累加**。

    - 有not null约束

      InnoDB引擎会遍历整张表把每一行的<u>字段值都取出来</u>，返回给服务层，直接按行进行**累加**。

  - `count(1)`：总记录数

    InnoDB引擎遍历整张表，但==不取值==。<u>服务层对于返回的每一行, 放一个数字1进去</u>，直接按行进行累加。

    > 把1换成其他数字也行，0都可以
  
  >按照**效率**排序的话，`count(字段)`<`count(主键id)`<`count(1)`≈`count(*)`，
  >所以建议使用`count(*)`，毕竟专门做了优化

---

### 七、update优化

#### (一) 问题

在事务中update时，如果筛选字段**有索引**，就是**行级锁**；如果**没有索引**/索引失效，就是**表级锁**

> 相比于行级锁，表级锁不利于事务并发

#### (二) 设计原则

在事务中update时，尽量利用索引

> 大总结：
>
> <img src="pics/image-20220321103923645.png" alt="image-20220321103923645" style="zoom:67%;" />
>
> 大部分情况下都是在**优化索引**

---

---

## 数据库对象

---

### 一、视图

#### (一) 概述

视图(View)是一种<u>虚拟存在的表</u>。视图中的数据并不在数据库中实际存在，

行和列数据来自定义视图的**<u>查询</u>中使用的表**，并且是在<u>使用视图时动态生成的</u>。

> 这张表也叫**基表**

通俗的讲，视图只保存了==查询的DQL逻辑==，可以像<u>操作表</u>一样操作这条DQL语句的查询结果，但视图本身不保存**查询结果**。

> 视图是为了<u>保存DQL逻辑，复用DQL逻辑</u>而存在了

所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

#### (二) 语法

创建视图：

```sql
create [or replace] view 视图名[(列名列表)] as select语句 
	[with [cascaded|local] check option]
```

> `[]`中的内容可以省略

查询视图：

- 查看创建视图语句：

  ```sql
  show create view 视图名称
  ```

- <u>查询视图数据</u>：

  ```sql
  select ... from 视图名 where ...
  ```

  > 就和**查询表**一样

修改视图：

```sql
create or replace view 视图名[(列名列表)] as select语句 
	[with [cascaded|local] check option]
```

```sql
alter view 视图名称[(列名列表)] as select语句 
	[with [cascaded|local] check option]
```

删除视图：

```sql
drop view [if exists] 视图名称 [, 视图名称]
```

> 也可以对视图使用<u>增删改</u>的语法（DML），但实际上是<u>间接DML了**基表**</u>。再次查询视图时当然也可以看到修改的数据（当然，<u>直接修改基表</u>本来就是可以的，不受视图限制）
>
> > 要在创建视图DQL语句范围内，进行DML；
> >
> > 如果修改的数据在对应DQL语句之外....

#### (三) 检查选项

*指定检查选项：*

在创建或修改视图时，加入`with [cascaded|local] check option`：

```sql
create [or replace] view 视图名[(列名列表)] as select语句 
	with [cascaded|local] check option
```

*检查选项的作用：*

当使用WITH CHECK OPTION子句创建视图时，MySQL会<u>通过视图中的==筛选条件==，**检查正在更改的每个行**</u>，以使其符合视图的定义

> 插入，更新，删除操作时就会这样；
>
> 本质上是在==**检查*where*中的筛选条件**==，也就是说，看<u>**==这个条件要不要检查，怎样检查==**</u>
>
> > 为什么要有这种检查？
> >
> > 因为视图通常就是根据SQL的逻辑，**在基表中筛选出来的**，如果在修改视图时，又出现了<u>不符合筛选条件的数据</u>，就矛盾了

*CASCADED和LOCAL：*

MySQL允许<u>基于一个视图创建另一个视图</u>，它还会检查**依赖视图中的规则**以保持一致性。
 为了确定检查的范围, mysq|提供了两个选项：CASCADED和LOCAL，默认值为CASCADED。

> :star:在视图层叠中举例：
>
> <img src="pics/image-20220328153035888.png" alt="image-20220328153035888" style="zoom:50%;" />
>
> 在修改数据时，处于底层的视图的**筛选条件**都是会看一遍的（其实是在**<u>递归</u>**），
>
> 没有**检查选项**的、且上层没有`cascaded`的，就不检查，
>
> 有**检查选项**的肯定会检查，
>
> - 如果是`cascaded`，叠在下面的视图的**筛选条件**必定都要检查
> - 如果是`local`，叠在下面的视图的**筛选条件**还要看，
>   但检不检查，就要看它自己有没有**检查选项**了

#### (四) 视图的更新

要使视图可更新，视图中的行与基础表中的行之间必须存在**<u>一对一</u>**的关系。

如果视图包含以下任何一项, 则该视图不可更新：

- 聚合函数或窗口函数
- `distinct`
- `group by ...`(`having ...`)
- `union` / `union all`

#### (五) 视图的作用

- 通过视图==**复用**SQL逻辑==，简化操作

  > 就像调用封装好的**小函数**

- 通过视图控制用户访问数据的**权限**

  > MySQL中的授权是针对表的，**粒度**没有到达**行**和**列**

- 视图可以帮助用户**屏蔽**真实表结构变化带来的影响

  >相当于在真实表上覆盖了一层，是可以对这层进行自主修改的，保证视图的独立性

---

### 二、存储过程

#### (一) 概述

概念：

- 存储过程是事先经过**编译**并存储在数据库中的一段<u>SQL语句的集合</u>，
  调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，
  对于提高数据处理的效率是有好处的。
- 存储过程思想上很简单,就是==数据库SQL语言层面的代码封装与重用==。

特点：

- **封装**、**复用**
- 可以**接收参数**，也可以**返回数据**
- 减少**网络**交互，效率提升

> 存储过程存储在**数据字典**中

#### (二) 语法

创建：

```sql
create procedure 存储过程名称([参数列表]) begin
	SQL语句;
end;
```

> 如果在命令行中直接这样写，肯定是不行的，因为遇到分号就会认为执行结束了。
> 此时需要关键字`delimiter`，<u>重新定义SQL语句的结束符</u>
>
> ```shell
> mysql> delimiter $$
> mysql> create procedure 存储过程名称([参数列表]) begin
> mysql>   SQL语句;
> mysql> end$$
> mysql> delimiter ; #f
> ```

调用：

```sql
call 存储过程名称([参数列表])
```

查看：

- 通过**系统表**，查看一个**数据库**下的所有存储过程：

  ```sql
  select * from information_schema.routines where routine_schema = '数据库名';
  ```

- 查看一个存储过程的创建语句

  ```sql
  show create procedure 存储过程名;
  ```

删除：

```sql
drop procedure [if exists] 存储过程名;
```

#### (三) 变量

##### 1、系统变量

- 系统变量是MySQL服务器提供，不是用户定义的，属于**服务器**层面。

- 分为**全局**变量(*GLOBAL*)、**会话**变量(*SESSION*) 。

  > 比如，一个query console就是一个会话，一个终端就是一个会话，
  > 也就是一次链接/一次Connection

- 查看系统变量：

  ```sql
  show [session|global] variables; #查看所有系统变量
  show [session|global] variables like '...'; #模糊匹配查看系统变量
  select @@[session|global].系统变量名; #根据系统变量名查找
  ```

  > 不指定级别的情况下**默认**是`session`

  > 举例：
  >
  > ```sql
  > show variables like 'auto%';
  > ```
  >
  > <img src="pics/image-20220330170319005.png" alt="image-20220330170319005" style="zoom:67%;" />

- 设置系统变量

  ```sql
  set [session|global] 系统变量名 = 值;
  set @@[session|global]系统变量名 = 值;
  ```

  > 注意，就算在会话中修改了全局变量，当***mysql*进程**重新启动后，还会恢复默认值；
  >
  > 如果想修改默认值，要去*/etc/my.cnf*中修改

##### 2、用户自定义变量

- 用户根据需要自己定义的变量，用户<u>不需要提前声明</u>，在用的时候直接用`@变量名`的语法就可以

  > 系统变量用`@@`，用户自定义变量用`@`

  > 用户定义的变量无需对其进行声明或初始化，
  > 只不过不赋值时获取到的值为NULL，并不会报错

- 其作用域默认为**当前链接/会话**

- 赋值：

  ```sql
  set @var_name = expr [, @var_name = expr] ...;
  set @var_name := expr [, @var_name := expr] ...;
  select @var_name := expr [, @var_name := expr] ...;
  select 字段名 into @var_name from 表名;
  ```

  > 推荐赋值时使用`:=`，因为在mysql中，`=`常用作判等
  >
  > > mysql中没有`==`

- 使用：

  ```sql
  select @var_name [, @var_name] ...;
  ```

##### 3、局部变量

- 局部变量是根据需要**定义**的<u>在局部生效</u>的变量，访问之前，需要<u>***DECLARE***声明</u>。

- 可用作<u>存储过程</u>内的**局部变量**和**输入参数**，局部变量的**范围**是在其声明的`BEGIN .. END`块。

- 声明：

  ```sql
  declare 变量名 变量类型 [default ...];
  ```

  > 变量类型和定义表时可以用的变量类型相同；
  >
  > 这个声明语句要放在存储过程定义的`begin ... end`中，其他位置不行，
  > 下面的赋值和查看也是

- 赋值：

  ```sql
  set 变量名 = 值;
  set 变量名 := 值;
  select 字段名 into 变量名 from 表名 ...;
  ```

  > 注意不能用`select 变量名 := 值`这种设置用户变量的语法了

- 查看：

  ```sql
  select 变量名
  ```

#### (四) 参数

IN 类型

- 输入参数，调用时需要传入值

OUT 类型

- 输出参数，参数可以作为返回值

  > 也是写在参数列表里，一般要通过**用户自定义变量**接收

INOUT 类型

- 既可以作为输入参数，也可以作为输出参数

  > 需要传入一个初始化过的用户变量（这个用户变量也作为**接收**使用）

语法：

```sql
create procedure 存储过程名称([[in|out|inout] 参数名 参数类型]) begin
	SQL语句;
end;
```

> 默认是`in`类型

> 举例：
>
> ```sql
> create procedure p4(in score int, out result varchar(10)) begin
>     # declare score int default 58;
>     # declare result varchar(10);
>     if score >= 85 then
>         set result := '优秀';
>     elseif score >= 60 then
>         set result := '及格';
>     else
>         set result := '不及格';
>     end if;
>     # select result;
> end;
> call p4(98, @result);
> select @result;
> ```
>
> ```sql
> create procedure p5(inout score double) begin
>     set score := score * 0.5;
> end;
> set @score := 78;
> call p5(@score);
> select @score;
> ```

#### (五) 程序流程控制

- if条件判断：

  ```sql
  if 条件1 then
  	...
  elseif 条件2 then #可选
  	...
  else #可选
  	...
  end if;
  ```

- case分支

  ```sql
  case case_value
  	when when_value1 then statement_list1
  	[when when_value2 then statement_list2]
  	...
  	[else statement_list]
  end case;
  ```

  ```sql
  case
  	when search_condition1 then statement_list1
  	[when search_condition1 then statement_list1]
  	...
  	[else statement_list]
  end case;
  ```

  > 这个第二种用法就和if几乎相同了

- while循环

  ```sql
  while 条件 do
  	SQL逻辑...
  end while;
  ```

- repeat循环

  ```sql
  repeat
  	SQL逻辑...
  	until 条件
  end repeat
  ```

  > 满足条件了则退出循环；一定会执行一次

- loop循环

  - LOOP实现简单的循环，
    如果不在SQL逻辑中增加**退出循环**的条件，可以用其来实现简单的**死循环**。
  - LOOP可以配合一下两个语句使用:
    - `leave`：配合循环使用，退出循环。
    - `interate`：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。

  ```sql
  [begin_label:] loop
  	SQL逻辑...
  	[leave label;] # break
  	[iterate label;] # continue
  end loop [end_label];
  ```


#### (六) 游标、条件处理程序

> 局部变量只能接收单行单列的数据。如果想接收结果集，该用什么呢？

游标(*CURSOR*)是用来<u>存储查询**结果集**</u>的数据类型，
在**存储过程**和**函数**中可以使用游标对结果集进行循环的处理。

游标的使用包括游标的声明、OPEN、FETCH 和CLOSE，其语法分别如下：

- 声明：

  ```sql
  declare 游标名称 cursor for 查询语句;
  ```

  > 注：游标的声明要先于**局部变量**

- 打开游标：

  ```sql
  open 游标名称;
  ```

  > 使用游标前必须先打开游标 

- 获取游标记录

  ```sql
  fetch 游标名称 into 变量[, 变量 ...];
  ```

  > 通常**获取记录**这个操作会放在<u>循环结构</u>中，需要用**局部变量**去接收结果；
  >
  > 怎么判断游标已经获取完了所有记录？需要用到下面提到的**条件处理程序**。

- 关闭游标

  ```sql
  close 游标名称;
  ```

条件处理程序（*Handler*）可以用来定义在流程控制结构执行过程中<u>**遇到问题**时相应的处理步骤</u>。
具体语法为：

```sql
declare hander_action 
	handler for condition_value[, condition_value] ... statement;
```

> handler_action：
>
> ```sql
> continue #继续执行当前程序
> exit # 终止当前程序
> ```
>
> condition
>
> ```sql
> sqlstate sqlstate_value # 状态码，如02000
> sqlwarning # 所有以01开头的SQLSTATE代码的简写
> not found # 所有以02开头的SQLSTATE代码的简写
> sqlexception # 所有没被sqlwarning或not found捕获的sqlstate代码的简写
> ```

> 游标与条件处理程序联合应用举例：
>
> ```sql
> create procedure p12() begin
>     declare u_name varchar(32);
>     declare u_phone varchar(16);
>     declare u_cursor cursor for select name, phone from t_admin;
> 
> 		#下面的sqlstate'02000'改成not found也行(在这个需求下)
>     declare exit handler for sqlstate '02000' close u_cursor;
> 		
>     open u_cursor;
>     while true do
>         fetch u_cursor into u_name, u_phone;
>         select u_name, u_phone;
>     end while;
> end;
> ```

---

### 三、存储函数

#### (一) 概述

存储函数是<u>有返回值</u>的**存储过程**，且存储函数的<u>参数只能是`IN`类型</u>的。

#### (二) 语法

创建：

```sql
create function 存储函数名([参数列表])
returns 返回值类型 [characteristic ...]
begin
	SQL逻辑;
	return ...;
end
```

> 关于`characteristic`(特性)：
>
> - `determinstic`：相同的输入参数总是产生**相同的结果**
> - `no sql`：不包含SQL语句
> - `reads sql data`：包含**读取数据**的SQL语句，但不包含**写入数据**的语句
>
> 在二进制日志开启的情况下，就必须指定`characteristic`
>
> > MySQL8.x默认就开启

调用：

```sql
select 存储函数名([参数值]);
set @var_name := 存储函数名([参数值]);
```

> 调用的时候不用`call`关键字，直接写函数名即可；
>
> 必须用某种方式接收返回值，不能直接调用就完了

> 举例：
>
> ```sql
> create function fun(n int)
>     returns int deterministic
> begin
>     declare total int default 0;
>     while n > 0
>         do
>             set total := total + n;
>             set n := n - 1;
>         end while;
>     return total;
> end;
> 
> select fun(100);
> ```

#### (三) 补充

存储函数中的**其他程序流程控制**与存储过程相同。

存储函数相对于存储过程来说用得比较少，因为能用存储函数解决的，也可以用存储过程解决。

----

### 四、触发器

#### (一) 概述

触发器是**与表有关**的数据库对象，
指在insert/update/delete之前或之后，<u>触发并执行</u>触发器中定义的**SQL语句集合**。

触发器的这种特性可以协助应用在数据库端确保<u>数据的完整性</u>，并进行日志记录、数据校验等操作。

使用别名OLD和NEW来引用触发器中<u>发生变化的**行记录**内容</u>

> 这与其他的数据库是相似的。
>
> <img src="pics/image-20220404085952571.png" alt="image-20220404085952571" style="zoom:67%;" />

现在触发器还只支持**行级触发**，不支持语句级触发。

> DML语句影响了多少行，就触发多少次，而不是一条DML语句只触发一次

#### (二) 语法

创建触发器：

```sql
create trigger trigger_name
before|after insert|update|delete
on tbl_name for each row # 行级触发器
begin
	trigger_stmt;
end;
```

查看触发器：

```sql
show triggers
```

删除触发器：

```sql
drop trigger [schema_name.]trigger_name;
```

> 如果没有指定数据库名，默认为当前数据库

> :star:总结：
>
> DQL===>视图
>
> DML+DQL===>存储过程
>
> DML===>触发器

---

---

## 锁

---

